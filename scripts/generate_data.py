"""
generate_data.py â€” Create 100 test customers with Stripe test clocks.

Simulates 6 months of billing history for a digital signage SaaS with:
- 5 pricing tiers (Free, Standard, Pro Plus, Engage, Enterprise)
- Per-screen subscriptions with varying screen counts
- Lifecycle events spread across 6 monthly phases

Test clock strategy:
- 34 test clocks (3 customers per clock, last clock has 1)
- Each clock starts 6 months ago
- 6 advances of 1 month each, with lifecycle events between advances

Run: uv run python scripts/generate_data.py
Prerequisite: Run seed_prices.py first (creates config/stripe_prices.json).
"""

import json
import os
import time
import random
from datetime import datetime, timezone
from pathlib import Path

import stripe
from dotenv import load_dotenv

load_dotenv()

stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

# ---------------------------------------------------------------------------
# Load price IDs from config (auto-generated by seed_prices.py)
# ---------------------------------------------------------------------------

CONFIG_DIR = Path(__file__).resolve().parent.parent / "config"
CONFIG_FILE = CONFIG_DIR / "stripe_prices.json"

if not CONFIG_FILE.exists():
    print(f"ERROR: {CONFIG_FILE} not found.")
    print("Run seed_prices.py first:  uv run python scripts/seed_prices.py")
    exit(1)

with open(CONFIG_FILE) as f:
    _config = json.load(f)

PRICE_IDS = _config["price_ids"]

# Price amounts in cents per screen per month
PRICE_AMOUNTS = {
    "free": 0,
    "standard": 1000,
    "pro_plus": 1500,
    "engage": 3000,
    "enterprise": 4500,
}

# Screen count ranges per plan
SCREEN_RANGES = {
    "free": (1, 3),
    "standard": (2, 8),
    "pro_plus": (5, 20),
    "engage": (8, 30),
    "enterprise": (25, 100),
}

# Customer distribution: 25 Free, 18 Standard, 32 Pro Plus, 15 Engage, 10 Enterprise
CUSTOMER_PLANS = (
    ["free"] * 25
    + ["standard"] * 18
    + ["pro_plus"] * 32
    + ["engage"] * 15
    + ["enterprise"] * 10
)

# Ordered tiers from lowest to highest
TIER_ORDER = ["free", "standard", "pro_plus", "engage", "enterprise"]

# Lifecycle events spread across 6 monthly phases
# Total: 15 upgrades, 2 downgrades, 8 cancellations
LIFECYCLE_PHASES = [
    {"upgrades": 2, "downgrades": 0, "cancellations": 1},
    {"upgrades": 3, "downgrades": 1, "cancellations": 1},
    {"upgrades": 2, "downgrades": 0, "cancellations": 2},
    {"upgrades": 3, "downgrades": 1, "cancellations": 1},
    {"upgrades": 3, "downgrades": 0, "cancellations": 2},
    {"upgrades": 2, "downgrades": 0, "cancellations": 1},
]

RATE_LIMIT_SLEEP = 0.25  # seconds between API calls


def sleep():
    """Rate limit safety."""
    time.sleep(RATE_LIMIT_SLEEP)


def cleanup_existing_test_clocks():
    """Delete all existing test clocks to start fresh."""
    print("=== Cleanup: Deleting existing test clocks ===\n")
    clocks = stripe.test_helpers.TestClock.list(limit=100)
    count = 0
    for clock in clocks.auto_paging_iter():
        retries = 0
        while clock.status == "advancing" and retries < 60:
            print(f"  Waiting for clock {clock.id} to finish advancing... ({retries * 5}s)")
            time.sleep(5)
            clock = stripe.test_helpers.TestClock.retrieve(clock.id)
            retries += 1

        try:
            print(f"  Deleting clock {clock.id} ({clock.name})")
            stripe.test_helpers.TestClock.delete(clock.id)
            sleep()
            count += 1
        except stripe._error.RateLimitError:
            print(f"  Could not delete clock {clock.id} (still advancing), skipping.")

    if count == 0:
        print("  No test clocks deleted.")
    else:
        print(f"  Deleted {count} test clocks.")
    print()


def months_ago_timestamp(n_months):
    """Return Unix timestamp for n months ago, 1st of that month at midnight UTC."""
    now = datetime.now(timezone.utc)
    month = now.month - n_months
    year = now.year
    while month <= 0:
        month += 12
        year -= 1
    target = datetime(year, month, 1, 0, 0, 0, tzinfo=timezone.utc)
    return int(target.timestamp())


def advance_timestamp(base_ts, months_forward):
    """Given a base timestamp, return timestamp months_forward months later."""
    base = datetime.fromtimestamp(base_ts, tz=timezone.utc)
    month = base.month + months_forward
    year = base.year
    while month > 12:
        month -= 12
        year += 1
    target = datetime(year, month, base.day, 0, 0, 0, tzinfo=timezone.utc)
    return int(target.timestamp())


def wait_for_clock(clock_id, max_wait=300):
    """Poll test clock until status is 'ready', with timeout."""
    start = time.time()
    while True:
        clock = stripe.test_helpers.TestClock.retrieve(clock_id)
        if clock.status == "ready":
            return clock
        if clock.status == "internal_failure":
            print(f"  ERROR: Clock {clock_id} failed internally.")
            return clock
        elapsed = time.time() - start
        if elapsed > max_wait:
            print(f"  TIMEOUT: Clock {clock_id} still {clock.status} after {max_wait}s, skipping.")
            return clock
        print(f"    Clock {clock_id} status={clock.status}, waiting... ({int(elapsed)}s)")
        time.sleep(5)


def get_month_label(base_ts, months_forward):
    """Get YYYY-MM string for a month offset from base timestamp."""
    base = datetime.fromtimestamp(base_ts, tz=timezone.utc)
    month = base.month + months_forward
    year = base.year
    while month > 12:
        month -= 12
        year += 1
    return f"{year}-{month:02d}"


# ---------------------------------------------------------------------------
# Customer + Subscription creation
# ---------------------------------------------------------------------------


def create_customer_with_sub(clock_id, customer_index, plan):
    """Create a customer attached to a test clock with a subscription."""
    screen_count = random.randint(*SCREEN_RANGES[plan])

    customer = stripe.Customer.create(
        name=f"Test Customer {customer_index:03d}",
        email=f"customer{customer_index:03d}@test.example.com",
        test_clock=clock_id,
        payment_method="pm_card_visa",
        invoice_settings={"default_payment_method": "pm_card_visa"},
        metadata={"plan": plan, "screens": str(screen_count)},
    )
    sleep()

    sub = stripe.Subscription.create(
        customer=customer.id,
        items=[{"price": PRICE_IDS[plan], "quantity": screen_count}],
        payment_settings={"payment_method_types": ["card"]},
        metadata={"initial_plan": plan, "initial_screens": str(screen_count)},
    )
    sleep()

    return {
        "customer_id": customer.id,
        "subscription_id": sub.id,
        "plan": plan,
        "screens": screen_count,
        "index": customer_index,
        "clock_id": clock_id,
        "cancelled": False,
    }


# ---------------------------------------------------------------------------
# Lifecycle event selectors
# ---------------------------------------------------------------------------


def select_upgrade_candidates(customers, count):
    eligible = [
        c for c in customers
        if c["plan"] != "enterprise" and not c["cancelled"]
    ]
    random.shuffle(eligible)
    return eligible[:count]


def select_downgrade_candidates(customers, count):
    eligible = [
        c for c in customers
        if c["plan"] != "free" and not c["cancelled"]
    ]
    random.shuffle(eligible)
    return eligible[:count]


def select_cancel_candidates(customers, count):
    eligible_priority = [
        c for c in customers
        if c["plan"] in ("free", "standard") and not c["cancelled"]
    ]
    eligible_other = [
        c for c in customers
        if c["plan"] not in ("free", "standard") and not c["cancelled"]
    ]
    random.shuffle(eligible_priority)
    random.shuffle(eligible_other)
    candidates = eligible_priority + eligible_other
    return candidates[:count]


# ---------------------------------------------------------------------------
# Lifecycle event appliers
# ---------------------------------------------------------------------------


def apply_upgrade(customer_info):
    sub = stripe.Subscription.retrieve(customer_info["subscription_id"])
    if sub.status in ("canceled", "incomplete_expired"):
        print(f"    Skipping #{customer_info['index']:03d}: subscription {sub.status}")
        customer_info["cancelled"] = True
        return

    current_plan = customer_info["plan"]
    current_idx = TIER_ORDER.index(current_plan)

    if random.random() < 0.5:
        higher_tiers = TIER_ORDER[current_idx + 1:]
        if higher_tiers:
            weights = list(range(len(higher_tiers), 0, -1))
            new_plan = random.choices(higher_tiers, weights=weights, k=1)[0]
            new_screens = customer_info["screens"]
            min_screens = SCREEN_RANGES[new_plan][0]
            if new_screens < min_screens:
                new_screens = random.randint(min_screens, SCREEN_RANGES[new_plan][1])

            stripe.Subscription.modify(
                customer_info["subscription_id"],
                items=[{
                    "id": sub["items"]["data"][0].id,
                    "price": PRICE_IDS[new_plan],
                    "quantity": new_screens,
                }],
                proration_behavior="none",
            )
            sleep()
            print(f"    Upgraded #{customer_info['index']:03d}: {current_plan} -> {new_plan}")
            customer_info["plan"] = new_plan
            customer_info["screens"] = new_screens
            return

    new_screens = customer_info["screens"] + random.randint(2, 10)
    max_screens = SCREEN_RANGES[current_plan][1]
    new_screens = min(new_screens, max_screens + 20)

    stripe.Subscription.modify(
        customer_info["subscription_id"],
        items=[{
            "id": sub["items"]["data"][0].id,
            "quantity": new_screens,
        }],
        proration_behavior="none",
    )
    sleep()
    print(f"    Upgraded #{customer_info['index']:03d}: screens {customer_info['screens']} -> {new_screens}")
    customer_info["screens"] = new_screens


def apply_downgrade(customer_info):
    sub = stripe.Subscription.retrieve(customer_info["subscription_id"])
    if sub.status in ("canceled", "incomplete_expired"):
        print(f"    Skipping #{customer_info['index']:03d}: subscription {sub.status}")
        customer_info["cancelled"] = True
        return

    current_plan = customer_info["plan"]
    current_idx = TIER_ORDER.index(current_plan)
    lower_tiers = TIER_ORDER[:current_idx]
    if not lower_tiers:
        return

    weights = list(range(1, len(lower_tiers) + 1))
    new_plan = random.choices(lower_tiers, weights=weights, k=1)[0]
    new_screens = min(customer_info["screens"], SCREEN_RANGES[new_plan][1])

    stripe.Subscription.modify(
        customer_info["subscription_id"],
        items=[{
            "id": sub["items"]["data"][0].id,
            "price": PRICE_IDS[new_plan],
            "quantity": new_screens,
        }],
        proration_behavior="none",
    )
    sleep()
    print(f"    Downgraded #{customer_info['index']:03d}: {current_plan} -> {new_plan}")
    customer_info["plan"] = new_plan
    customer_info["screens"] = new_screens


def apply_cancellation(customer_info):
    stripe.Subscription.cancel(customer_info["subscription_id"])
    sleep()
    print(f"    Cancelled #{customer_info['index']:03d} ({customer_info['plan']})")
    customer_info["cancelled"] = True


# ---------------------------------------------------------------------------
# Snapshot helper
# ---------------------------------------------------------------------------


def take_snapshot(all_customers, month_label):
    """Capture the current state of every active customer for a given month."""
    snapshot = []
    for c in all_customers:
        if not c["cancelled"]:
            snapshot.append({
                "month": month_label,
                "customer_id": c["customer_id"],
                "subscription_id": c["subscription_id"],
                "plan": c["plan"],
                "price_id": PRICE_IDS[c["plan"]],
                "price_amount": PRICE_AMOUNTS[c["plan"]],
                "screens": c["screens"],
                "mrr_cents": PRICE_AMOUNTS[c["plan"]] * c["screens"],
            })
    return snapshot


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


def main():
    random.shuffle(CUSTOMER_PLANS)
    cleanup_existing_test_clocks()
    frozen_time = months_ago_timestamp(6)
    all_customers = []
    clocks = []
    all_snapshots = []

    batches = []
    for i in range(0, len(CUSTOMER_PLANS), 3):
        batches.append(CUSTOMER_PLANS[i:i + 3])

    print(f"Creating {len(CUSTOMER_PLANS)} customers across {len(batches)} test clocks...\n")
    print(f"Frozen time: {datetime.fromtimestamp(frozen_time, tz=timezone.utc).isoformat()}\n")

    # --- Phase 1: Create all clocks, customers, and subscriptions ---
    print("=== Phase 1: Creating test clocks, customers, and subscriptions ===\n")

    customer_index = 1
    for batch_num, batch in enumerate(batches):
        clock = stripe.test_helpers.TestClock.create(
            frozen_time=frozen_time,
            name=f"MRR Clock {batch_num + 1:02d}",
        )
        sleep()
        clocks.append(clock.id)

        print(f"Clock {batch_num + 1}/{len(batches)} ({clock.id}):")

        for plan in batch:
            info = create_customer_with_sub(clock.id, customer_index, plan)
            all_customers.append(info)
            print(f"  Customer #{customer_index:03d}: {plan}, {info['screens']} screens")
            customer_index += 1

    # Snapshot month 0 (creation month)
    month_0 = get_month_label(frozen_time, 0)
    all_snapshots.extend(take_snapshot(all_customers, month_0))
    print(f"\nSnapshot for {month_0}: {len([c for c in all_customers if not c['cancelled']])} active customers")

    # --- Phases 2-7: Advance 1 month at a time, apply events, snapshot ---

    for phase_num, phase in enumerate(LIFECYCLE_PHASES):
        advance_months = phase_num + 1
        advance_to = advance_timestamp(frozen_time, advance_months)
        month_label = get_month_label(frozen_time, advance_months)

        print(f"\n=== Phase {phase_num + 2}: Month {advance_months} ({month_label}) ===\n")

        # Advance all clocks
        print(f"Advancing to {datetime.fromtimestamp(advance_to, tz=timezone.utc).isoformat()}")
        for clock_id in clocks:
            stripe.test_helpers.TestClock.advance(clock_id, frozen_time=advance_to)
            sleep()

        print("Waiting for all clocks to process...")
        for clock_id in clocks:
            wait_for_clock(clock_id)
        print("All clocks ready.\n")

        # Apply upgrades
        if phase["upgrades"] > 0:
            candidates = select_upgrade_candidates(all_customers, phase["upgrades"])
            print(f"Applying {len(candidates)} upgrades:")
            for c in candidates:
                apply_upgrade(c)

        # Apply downgrades
        if phase["downgrades"] > 0:
            candidates = select_downgrade_candidates(all_customers, phase["downgrades"])
            print(f"\nApplying {len(candidates)} downgrades:")
            for c in candidates:
                apply_downgrade(c)

        # Apply cancellations
        if phase["cancellations"] > 0:
            candidates = select_cancel_candidates(all_customers, phase["cancellations"])
            print(f"\nApplying {len(candidates)} cancellations:")
            for c in candidates:
                apply_cancellation(c)

        # Snapshot after changes
        all_snapshots.extend(take_snapshot(all_customers, month_label))
        active_count = len([c for c in all_customers if not c["cancelled"]])
        print(f"\nSnapshot for {month_label}: {active_count} active customers")

    # --- Save snapshots ---
    snapshots_file = CONFIG_DIR / "sub_snapshots.json"
    with open(snapshots_file, "w") as f:
        json.dump(all_snapshots, f, indent=2)
    print(f"\nSaved {len(all_snapshots)} subscription snapshots to {snapshots_file}")

    # --- Save run metadata ---
    output = {
        "run_timestamp": datetime.now(timezone.utc).isoformat(),
        "customer_ids": [c["customer_id"] for c in all_customers],
        "clock_ids": clocks,
    }
    output_file = CONFIG_DIR / "current_run.json"
    output_file.parent.mkdir(exist_ok=True)
    with open(output_file, "w") as f:
        json.dump(output, f, indent=2)
    print(f"Saved run metadata to {output_file}")

    # --- Summary ---
    print("\n=== Summary ===\n")
    active = [c for c in all_customers if not c["cancelled"]]
    cancelled = [c for c in all_customers if c["cancelled"]]
    print(f"Total customers created: {len(all_customers)}")
    print(f"Active subscriptions:    {len(active)}")
    print(f"Cancelled:               {len(cancelled)}")
    print(f"Test clocks used:        {len(clocks)}")

    plan_counts = {}
    for c in active:
        plan_counts[c["plan"]] = plan_counts.get(c["plan"], 0) + 1
    print(f"\nActive customers by plan:")
    for plan in TIER_ORDER:
        count = plan_counts.get(plan, 0)
        print(f"  {plan}: {count}")


if __name__ == "__main__":
    main()