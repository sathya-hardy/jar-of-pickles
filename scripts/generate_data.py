"""
generate_data.py â€” Create 100 test customers with Stripe test clocks.

Simulates 6 months of billing history for a digital signage SaaS with:
- 5 pricing tiers (Free, Standard, Pro Plus, Engage, Enterprise)
- Per-screen subscriptions with varying screen counts
- Lifecycle events spread across 6 monthly phases (upgrades, downgrades,
  cancellations, and past_due via declining payment methods)

Test clock strategy:
- 34 test clocks (3 customers per clock, last clock has 1)
- Each clock starts 6 months ago
- 6 advances of 1 month each, with lifecycle events between advances

Run: uv run python scripts/generate_data.py
Prerequisite: Run seed_prices.py first (creates config/stripe_prices.json).
"""

import json
import os
import time
import random
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime, timezone
from pathlib import Path

import stripe
from dotenv import load_dotenv

load_dotenv()

stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

# ---------------------------------------------------------------------------
# Load price IDs from config (auto-generated by seed_prices.py)
# ---------------------------------------------------------------------------

CONFIG_DIR = Path(__file__).resolve().parent.parent / "config"
CONFIG_FILE = CONFIG_DIR / "stripe_prices.json"

if not CONFIG_FILE.exists():
    print(f"ERROR: {CONFIG_FILE} not found.")
    print("Run seed_prices.py first:  uv run python scripts/seed_prices.py")
    exit(1)

with open(CONFIG_FILE) as f:
    _config = json.load(f)

PRICE_IDS = _config["price_ids"]

# Price amounts in cents per screen per month
PRICE_AMOUNTS = {
    "free": 0,
    "standard": 1000,
    "pro_plus": 1500,
    "engage": 3000,
    "enterprise": 4500,
}

# Screen count ranges per plan
SCREEN_RANGES = {
    "free": (1, 3),
    "standard": (2, 8),
    "pro_plus": (5, 20),
    "engage": (8, 30),
    "enterprise": (25, 100),
}

# Customer distribution: 25 Free, 18 Standard, 32 Pro Plus, 15 Engage, 10 Enterprise
CUSTOMER_PLANS = (
    ["free"] * 25
    + ["standard"] * 18
    + ["pro_plus"] * 32
    + ["engage"] * 15
    + ["enterprise"] * 10
)

# Ordered tiers from lowest to highest
TIER_ORDER = ["free", "standard", "pro_plus", "engage", "enterprise"]

# Lifecycle events spread across 6 monthly phases
# Total: 15 upgrades, 2 downgrades, 8 cancellations, 5 past_due
LIFECYCLE_PHASES = [
    {"upgrades": 2, "downgrades": 0, "cancellations": 1, "past_dues": 1},
    {"upgrades": 3, "downgrades": 1, "cancellations": 1, "past_dues": 1},
    {"upgrades": 2, "downgrades": 0, "cancellations": 2, "past_dues": 1},
    {"upgrades": 3, "downgrades": 1, "cancellations": 1, "past_dues": 0},
    {"upgrades": 3, "downgrades": 0, "cancellations": 2, "past_dues": 1},
    {"upgrades": 2, "downgrades": 0, "cancellations": 1, "past_dues": 1},
]

RATE_LIMIT_SLEEP = 0.25  # seconds between API calls
MAX_WORKERS = 10         # thread pool size (stays well under Stripe's 25 req/s test limit)


def sleep():
    """Rate limit safety."""
    time.sleep(RATE_LIMIT_SLEEP)


def cleanup_existing_test_clocks():
    """Delete all existing test clocks in parallel."""
    print("=== Cleanup: Deleting existing test clocks ===\n")

    # Collect all clock IDs first
    clock_ids = [c.id for c in stripe.test_helpers.TestClock.list(limit=100).auto_paging_iter()]
    if not clock_ids:
        print("  No test clocks to delete.\n")
        return

    print(f"  Found {len(clock_ids)} test clocks.")

    # Wait for any advancing clocks (batch poll)
    wait_for_all_clocks(clock_ids, label="pre-delete")

    # Delete in parallel
    def _delete_clock(clock_id):
        try:
            stripe.test_helpers.TestClock.delete(clock_id)
            return clock_id, True
        except stripe._error.RateLimitError:
            return clock_id, False

    deleted = 0
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as pool:
        futures = {pool.submit(_delete_clock, cid): cid for cid in clock_ids}
        for future in as_completed(futures):
            cid, ok = future.result()
            if ok:
                deleted += 1

    print(f"  Deleted {deleted}/{len(clock_ids)} test clocks.\n")


def months_ago_timestamp(n_months):
    """Return Unix timestamp for n months ago, 1st of that month at midnight UTC."""
    now = datetime.now(timezone.utc)
    month = now.month - n_months
    year = now.year
    while month <= 0:
        month += 12
        year -= 1
    target = datetime(year, month, 1, 0, 0, 0, tzinfo=timezone.utc)
    return int(target.timestamp())


def advance_timestamp(base_ts, months_forward):
    """Given a base timestamp, return timestamp months_forward months later."""
    base = datetime.fromtimestamp(base_ts, tz=timezone.utc)
    month = base.month + months_forward
    year = base.year
    while month > 12:
        month -= 12
        year += 1
    target = datetime(year, month, base.day, 0, 0, 0, tzinfo=timezone.utc)
    return int(target.timestamp())


def wait_for_all_clocks(clock_ids, max_wait=300, label=""):
    """Poll all clocks concurrently until every one is 'ready' or failed/timed-out.

    Instead of waiting for clock 1, then clock 2, etc., this checks all of
    them in a single batch per iteration. Clocks that finish early are removed
    from the poll set immediately, so the total wait is ~max(individual waits)
    rather than sum(individual waits).
    """
    pending = set(clock_ids)
    start = time.time()

    while pending:
        elapsed = time.time() - start
        if elapsed > max_wait:
            print(f"  TIMEOUT: {len(pending)} clocks still not ready after {max_wait}s{f' ({label})' if label else ''}")
            break

        # Poll all pending clocks in parallel
        def _check(cid):
            return cid, stripe.test_helpers.TestClock.retrieve(cid)

        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as pool:
            results = list(pool.map(_check, list(pending)))

        newly_done = []
        for cid, clock in results:
            if clock.status == "ready":
                newly_done.append(cid)
            elif clock.status == "internal_failure":
                print(f"  ERROR: Clock {cid} failed internally.")
                newly_done.append(cid)

        for cid in newly_done:
            pending.discard(cid)

        if pending:
            print(f"    {len(pending)} clocks still processing... ({int(elapsed)}s)")
            time.sleep(5)


def get_month_label(base_ts, months_forward):
    """Get YYYY-MM string for a month offset from base timestamp."""
    base = datetime.fromtimestamp(base_ts, tz=timezone.utc)
    month = base.month + months_forward
    year = base.year
    while month > 12:
        month -= 12
        year += 1
    return f"{year}-{month:02d}"


# ---------------------------------------------------------------------------
# Customer + Subscription creation
# ---------------------------------------------------------------------------


def create_customer_with_sub(clock_id, customer_index, plan):
    """Create a customer attached to a test clock with a subscription."""
    screen_count = random.randint(*SCREEN_RANGES[plan])

    customer = stripe.Customer.create(
        name=f"Test Customer {customer_index:03d}",
        email=f"customer{customer_index:03d}@test.example.com",
        test_clock=clock_id,
        payment_method="pm_card_visa",
        invoice_settings={"default_payment_method": "pm_card_visa"},
        metadata={"plan": plan, "screens": str(screen_count)},
    )
    sleep()

    sub = stripe.Subscription.create(
        customer=customer.id,
        items=[{"price": PRICE_IDS[plan], "quantity": screen_count}],
        payment_settings={"payment_method_types": ["card"]},
        metadata={"initial_plan": plan, "initial_screens": str(screen_count)},
    )
    sleep()

    return {
        "customer_id": customer.id,
        "subscription_id": sub.id,
        "plan": plan,
        "screens": screen_count,
        "index": customer_index,
        "clock_id": clock_id,
        "cancelled": False,
        "past_due": False,
    }


# ---------------------------------------------------------------------------
# Lifecycle event selectors
# ---------------------------------------------------------------------------


def select_upgrade_candidates(customers, count):
    eligible = [
        c for c in customers
        if c["plan"] != "enterprise" and not c["cancelled"]
    ]
    random.shuffle(eligible)
    return eligible[:count]


def select_downgrade_candidates(customers, count):
    eligible = [
        c for c in customers
        if c["plan"] != "free" and not c["cancelled"]
    ]
    random.shuffle(eligible)
    return eligible[:count]


def select_cancel_candidates(customers, count):
    eligible_priority = [
        c for c in customers
        if c["plan"] in ("free", "standard") and not c["cancelled"]
    ]
    eligible_other = [
        c for c in customers
        if c["plan"] not in ("free", "standard") and not c["cancelled"]
    ]
    random.shuffle(eligible_priority)
    random.shuffle(eligible_other)
    candidates = eligible_priority + eligible_other
    return candidates[:count]


def select_past_due_candidates(customers, count):
    """Select paying, active, non-past-due customers to mark as past_due."""
    eligible = [
        c for c in customers
        if not c["cancelled"]
        and not c.get("past_due")
        and c["plan"] != "free"  # free tier has no charge to fail
    ]
    random.shuffle(eligible)
    return eligible[:count]


# ---------------------------------------------------------------------------
# Lifecycle event appliers
# ---------------------------------------------------------------------------


def apply_upgrade(customer_info):
    sub = stripe.Subscription.retrieve(customer_info["subscription_id"])
    if sub.status in ("canceled", "incomplete_expired"):
        print(f"    Skipping #{customer_info['index']:03d}: subscription {sub.status}")
        customer_info["cancelled"] = True
        return

    current_plan = customer_info["plan"]
    current_idx = TIER_ORDER.index(current_plan)

    if random.random() < 0.5:
        higher_tiers = TIER_ORDER[current_idx + 1:]
        if higher_tiers:
            weights = list(range(len(higher_tiers), 0, -1))
            new_plan = random.choices(higher_tiers, weights=weights, k=1)[0]
            new_screens = customer_info["screens"]
            min_screens = SCREEN_RANGES[new_plan][0]
            if new_screens < min_screens:
                new_screens = random.randint(min_screens, SCREEN_RANGES[new_plan][1])

            stripe.Subscription.modify(
                customer_info["subscription_id"],
                items=[{
                    "id": sub["items"]["data"][0].id,
                    "price": PRICE_IDS[new_plan],
                    "quantity": new_screens,
                }],
                proration_behavior="none",
            )
            sleep()
            print(f"    Upgraded #{customer_info['index']:03d}: {current_plan} -> {new_plan}")
            customer_info["plan"] = new_plan
            customer_info["screens"] = new_screens
            return

    new_screens = customer_info["screens"] + random.randint(2, 10)
    max_screens = SCREEN_RANGES[current_plan][1]
    new_screens = min(new_screens, max_screens + 20)

    stripe.Subscription.modify(
        customer_info["subscription_id"],
        items=[{
            "id": sub["items"]["data"][0].id,
            "quantity": new_screens,
        }],
        proration_behavior="none",
    )
    sleep()
    print(f"    Upgraded #{customer_info['index']:03d}: screens {customer_info['screens']} -> {new_screens}")
    customer_info["screens"] = new_screens


def apply_downgrade(customer_info):
    sub = stripe.Subscription.retrieve(customer_info["subscription_id"])
    if sub.status in ("canceled", "incomplete_expired"):
        print(f"    Skipping #{customer_info['index']:03d}: subscription {sub.status}")
        customer_info["cancelled"] = True
        return

    current_plan = customer_info["plan"]
    current_idx = TIER_ORDER.index(current_plan)
    lower_tiers = TIER_ORDER[:current_idx]
    if not lower_tiers:
        return

    weights = list(range(1, len(lower_tiers) + 1))
    new_plan = random.choices(lower_tiers, weights=weights, k=1)[0]
    new_screens = min(customer_info["screens"], SCREEN_RANGES[new_plan][1])

    stripe.Subscription.modify(
        customer_info["subscription_id"],
        items=[{
            "id": sub["items"]["data"][0].id,
            "price": PRICE_IDS[new_plan],
            "quantity": new_screens,
        }],
        proration_behavior="none",
    )
    sleep()
    print(f"    Downgraded #{customer_info['index']:03d}: {current_plan} -> {new_plan}")
    customer_info["plan"] = new_plan
    customer_info["screens"] = new_screens


def apply_cancellation(customer_info):
    stripe.Subscription.cancel(customer_info["subscription_id"])
    sleep()
    print(f"    Cancelled #{customer_info['index']:03d} ({customer_info['plan']})")
    customer_info["cancelled"] = True


def apply_past_due(customer_info):
    """Switch customer to a declining card so the next invoice charge fails.

    Stripe will automatically set the subscription status to 'past_due'
    when the next billing attempt uses this card and the charge is declined.
    """
    # Attach a test card that always declines
    pm = stripe.PaymentMethod.attach(
        "pm_card_chargeDeclined",
        customer=customer_info["customer_id"],
    )
    sleep()
    # Set the declining card as the default so the next auto-charge uses it
    stripe.Customer.modify(
        customer_info["customer_id"],
        invoice_settings={"default_payment_method": pm.id},
    )
    sleep()
    print(f"    Past Due #{customer_info['index']:03d} ({customer_info['plan']})")
    customer_info["past_due"] = True


# ---------------------------------------------------------------------------
# Snapshot helper
# ---------------------------------------------------------------------------


def take_snapshot(all_customers, month_label):
    """Capture the current state of every active customer for a given month."""
    snapshot = []
    for c in all_customers:
        if not c["cancelled"]:
            status = "past_due" if c.get("past_due") else "active"
            snapshot.append({
                "month": month_label,
                "customer_id": c["customer_id"],
                "subscription_id": c["subscription_id"],
                "plan": c["plan"],
                "price_id": PRICE_IDS[c["plan"]],
                "price_amount": PRICE_AMOUNTS[c["plan"]],
                "screens": c["screens"],
                "mrr_cents": PRICE_AMOUNTS[c["plan"]] * c["screens"],
                "status": status,
            })
    return snapshot


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


def main():
    random.shuffle(CUSTOMER_PLANS)
    cleanup_existing_test_clocks()
    frozen_time = months_ago_timestamp(6)
    all_customers = []
    clocks = []
    all_snapshots = []

    batches = []
    for i in range(0, len(CUSTOMER_PLANS), 3):
        batches.append(CUSTOMER_PLANS[i:i + 3])

    print(f"Creating {len(CUSTOMER_PLANS)} customers across {len(batches)} test clocks...\n")
    print(f"Frozen time: {datetime.fromtimestamp(frozen_time, tz=timezone.utc).isoformat()}\n")

    # --- Phase 1: Create all clocks, customers, and subscriptions ---
    print("=== Phase 1: Creating test clocks, customers, and subscriptions ===\n")

    customer_index = 1
    for batch_num, batch in enumerate(batches):
        clock = stripe.test_helpers.TestClock.create(
            frozen_time=frozen_time,
            name=f"MRR Clock {batch_num + 1:02d}",
        )
        sleep()
        clocks.append(clock.id)

        print(f"Clock {batch_num + 1}/{len(batches)} ({clock.id}):")

        for plan in batch:
            info = create_customer_with_sub(clock.id, customer_index, plan)
            all_customers.append(info)
            print(f"  Customer #{customer_index:03d}: {plan}, {info['screens']} screens")
            customer_index += 1

    # Snapshot month 0 (creation month)
    month_0 = get_month_label(frozen_time, 0)
    all_snapshots.extend(take_snapshot(all_customers, month_0))
    print(f"\nSnapshot for {month_0}: {len([c for c in all_customers if not c['cancelled']])} active customers")

    # --- Phases 2-7: Advance 1 month at a time, apply events, snapshot ---

    for phase_num, phase in enumerate(LIFECYCLE_PHASES):
        advance_months = phase_num + 1
        advance_to = advance_timestamp(frozen_time, advance_months)
        month_label = get_month_label(frozen_time, advance_months)

        print(f"\n=== Phase {phase_num + 2}: Month {advance_months} ({month_label}) ===\n")

        # Advance all clocks in parallel
        print(f"Advancing {len(clocks)} clocks to {datetime.fromtimestamp(advance_to, tz=timezone.utc).isoformat()}")

        def _advance(cid):
            stripe.test_helpers.TestClock.advance(cid, frozen_time=advance_to)
            return cid

        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as pool:
            list(pool.map(_advance, clocks))

        # Wait for all clocks to finish processing (batch poll)
        print("Waiting for all clocks to process...")
        wait_for_all_clocks(clocks, label=f"month {advance_months}")
        print("All clocks ready.\n")

        # Apply upgrades
        if phase["upgrades"] > 0:
            candidates = select_upgrade_candidates(all_customers, phase["upgrades"])
            print(f"Applying {len(candidates)} upgrades:")
            for c in candidates:
                apply_upgrade(c)

        # Apply downgrades
        if phase["downgrades"] > 0:
            candidates = select_downgrade_candidates(all_customers, phase["downgrades"])
            print(f"\nApplying {len(candidates)} downgrades:")
            for c in candidates:
                apply_downgrade(c)

        # Apply cancellations
        if phase["cancellations"] > 0:
            candidates = select_cancel_candidates(all_customers, phase["cancellations"])
            print(f"\nApplying {len(candidates)} cancellations:")
            for c in candidates:
                apply_cancellation(c)

        # Apply past_due triggers (swap to declining card before next advance)
        if phase.get("past_dues", 0) > 0:
            candidates = select_past_due_candidates(all_customers, phase["past_dues"])
            print(f"\nApplying {len(candidates)} past_due triggers:")
            for c in candidates:
                apply_past_due(c)

        # Snapshot after changes
        all_snapshots.extend(take_snapshot(all_customers, month_label))
        active_count = len([c for c in all_customers if not c["cancelled"]])
        print(f"\nSnapshot for {month_label}: {active_count} active customers")

    # --- Save snapshots ---
    snapshots_file = CONFIG_DIR / "sub_snapshots.json"
    with open(snapshots_file, "w") as f:
        json.dump(all_snapshots, f, indent=2)
    print(f"\nSaved {len(all_snapshots)} subscription snapshots to {snapshots_file}")

    # --- Save run metadata ---
    output = {
        "run_timestamp": datetime.now(timezone.utc).isoformat(),
        "customer_ids": [c["customer_id"] for c in all_customers],
        "clock_ids": clocks,
    }
    output_file = CONFIG_DIR / "current_run.json"
    output_file.parent.mkdir(exist_ok=True)
    with open(output_file, "w") as f:
        json.dump(output, f, indent=2)
    print(f"Saved run metadata to {output_file}")

    # --- Summary ---
    print("\n=== Summary ===\n")
    active = [c for c in all_customers if not c["cancelled"]]
    cancelled = [c for c in all_customers if c["cancelled"]]
    past_due = [c for c in all_customers if c.get("past_due") and not c["cancelled"]]
    print(f"Total customers created: {len(all_customers)}")
    print(f"Active subscriptions:    {len(active)}")
    print(f"Past due:                {len(past_due)}")
    print(f"Cancelled:               {len(cancelled)}")
    print(f"Test clocks used:        {len(clocks)}")

    plan_counts = {}
    for c in active:
        plan_counts[c["plan"]] = plan_counts.get(c["plan"], 0) + 1
    print(f"\nActive customers by plan:")
    for plan in TIER_ORDER:
        count = plan_counts.get(plan, 0)
        print(f"  {plan}: {count}")


if __name__ == "__main__":
    main()