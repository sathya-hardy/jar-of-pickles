"""
generate_data.py — Create 100 test customers with Stripe test clocks.

Simulates 6 months of billing history for a digital signage SaaS with:
- 5 pricing tiers (Free, Standard, Pro Plus, Engage, Enterprise)
- Per-screen subscriptions with varying screen counts
- Growth story: ~15 upgrades, ~8 cancellations, ~2 downgrades

Test clock strategy:
- 34 test clocks (3 customers per clock, last clock has 1)
- Each clock starts 6 months ago
- 3 advances of 2 months each, with lifecycle events between advances

Run: uv run python scripts/generate_data.py
Prerequisite: Run seed_prices.py first (creates config/stripe_prices.json).
"""

import json
import os
import time
import random
from datetime import datetime, timezone
from pathlib import Path
import stripe
from dotenv import load_dotenv

load_dotenv()

stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

# ---------------------------------------------------------------------------
# Load price IDs from config (auto-generated by seed_prices.py)
# ---------------------------------------------------------------------------
CONFIG_FILE = Path(__file__).resolve().parent.parent / "config" / "stripe_prices.json"

if not CONFIG_FILE.exists():
    print(f"ERROR: {CONFIG_FILE} not found.")
    print("Run seed_prices.py first:  uv run python scripts/seed_prices.py")
    exit(1)

with open(CONFIG_FILE) as f:
    _config = json.load(f)

PRICE_IDS = _config["price_ids"]

# Screen count ranges per plan
SCREEN_RANGES = {
    "free": (1, 3),
    "standard": (2, 8),
    "pro_plus": (5, 20),
    "engage": (8, 30),
    "enterprise": (25, 100),
}

# Customer distribution: 25 Free, 18 Standard, 32 Pro Plus, 15 Engage, 10 Enterprise
CUSTOMER_PLANS = (
    ["free"] * 25
    + ["standard"] * 18
    + ["pro_plus"] * 32
    + ["engage"] * 15
    + ["enterprise"] * 10
)

# Ordered tiers from lowest to highest
TIER_ORDER = ["free", "standard", "pro_plus", "engage", "enterprise"]

# How many of each event
NUM_UPGRADES = 15
NUM_DOWNGRADES = 2
NUM_CANCELLATIONS = 8

RATE_LIMIT_SLEEP = 0.25  # seconds between API calls


def sleep():
    """Rate limit safety."""
    time.sleep(RATE_LIMIT_SLEEP)


def months_ago_timestamp(n_months):
    """Return Unix timestamp for n months ago, 1st of that month at midnight UTC."""
    now = datetime.now(timezone.utc)
    month = now.month - n_months
    year = now.year
    while month <= 0:
        month += 12
        year -= 1
    target = datetime(year, month, 1, 0, 0, 0, tzinfo=timezone.utc)
    return int(target.timestamp())


def advance_timestamp(base_ts, months_forward):
    """Given a base timestamp, return timestamp months_forward months later."""
    base = datetime.fromtimestamp(base_ts, tz=timezone.utc)
    month = base.month + months_forward
    year = base.year
    while month > 12:
        month -= 12
        year += 1
    target = datetime(year, month, base.day, 0, 0, 0, tzinfo=timezone.utc)
    return int(target.timestamp())


def wait_for_clock(clock_id):
    """Poll test clock until status is 'ready'."""
    while True:
        clock = stripe.test_helpers.TestClock.retrieve(clock_id)
        if clock.status == "ready":
            return clock
        print(f"    Clock {clock_id} status={clock.status}, waiting...")
        time.sleep(3)


def create_customer_with_sub(clock_id, customer_index, plan):
    """Create a customer attached to a test clock with a subscription."""
    screen_count = random.randint(*SCREEN_RANGES[plan])

    customer = stripe.Customer.create(
        name=f"Test Customer {customer_index:03d}",
        email=f"customer{customer_index:03d}@test.example.com",
        test_clock=clock_id,
        payment_method="pm_card_visa",
        invoice_settings={"default_payment_method": "pm_card_visa"},
        metadata={"plan": plan, "screens": str(screen_count)},
    )
    sleep()

    sub = stripe.Subscription.create(
        customer=customer.id,
        items=[{"price": PRICE_IDS[plan], "quantity": screen_count}],
        payment_settings={"payment_method_types": ["card"]},
        metadata={"initial_plan": plan, "initial_screens": str(screen_count)},
    )
    sleep()

    return {
        "customer_id": customer.id,
        "subscription_id": sub.id,
        "plan": plan,
        "screens": screen_count,
        "index": customer_index,
        "clock_id": clock_id,
        "cancelled": False,
    }


def select_upgrade_candidates(customers):
    """Select ~15 customers to upgrade. Any tier below enterprise is eligible."""
    eligible = [
        c for c in customers
        if c["plan"] != "enterprise" and not c["cancelled"]
    ]
    random.shuffle(eligible)
    return eligible[:NUM_UPGRADES]


def select_downgrade_candidates(customers):
    """Select ~2 customers to downgrade. Any tier above free is eligible."""
    eligible = [
        c for c in customers
        if c["plan"] != "free" and not c["cancelled"]
    ]
    random.shuffle(eligible)
    return eligible[:NUM_DOWNGRADES]


def select_cancel_candidates(customers):
    """Select ~8 customers to cancel. Weighted toward Free/Standard."""
    eligible_priority = [
        c for c in customers
        if c["plan"] in ("free", "standard") and not c["cancelled"]
    ]
    eligible_other = [
        c for c in customers
        if c["plan"] not in ("free", "standard") and not c["cancelled"]
    ]
    random.shuffle(eligible_priority)
    random.shuffle(eligible_other)
    candidates = eligible_priority + eligible_other
    return candidates[:NUM_CANCELLATIONS]


def apply_upgrade(customer_info):
    """Upgrade a customer to any higher tier or increase screen count."""
    sub = stripe.Subscription.retrieve(customer_info["subscription_id"])
    if sub.status in ("canceled", "incomplete_expired"):
        print(f"    Skipping #{customer_info['index']:03d}: subscription {sub.status}")
        customer_info["cancelled"] = True
        return

    current_plan = customer_info["plan"]
    current_idx = TIER_ORDER.index(current_plan)

    # 50% chance: plan upgrade, 50% chance: screen increase
    if random.random() < 0.5:
        # Pick any tier above current — weighted toward adjacent tiers
        higher_tiers = TIER_ORDER[current_idx + 1:]
        if higher_tiers:
            # Weight: adjacent tier most likely, further tiers less likely
            # e.g. from free: standard=4, pro_plus=3, engage=2, enterprise=1
            weights = list(range(len(higher_tiers), 0, -1))
            new_plan = random.choices(higher_tiers, weights=weights, k=1)[0]

            new_screens = customer_info["screens"]
            # Adjust screen count to fit new plan's range if needed
            min_screens = SCREEN_RANGES[new_plan][0]
            if new_screens < min_screens:
                new_screens = random.randint(min_screens, SCREEN_RANGES[new_plan][1])

            stripe.Subscription.modify(
                customer_info["subscription_id"],
                items=[{
                    "id": sub["items"]["data"][0].id,
                    "price": PRICE_IDS[new_plan],
                    "quantity": new_screens,
                }],
                proration_behavior="create_prorations",
            )
            sleep()
            print(f"    Upgraded #{customer_info['index']:03d}: {current_plan} -> {new_plan}")
            customer_info["plan"] = new_plan
            customer_info["screens"] = new_screens
            return
    # Screen increase
    new_screens = customer_info["screens"] + random.randint(2, 10)
    max_screens = SCREEN_RANGES[current_plan][1]
    new_screens = min(new_screens, max_screens + 20)

    stripe.Subscription.modify(
        customer_info["subscription_id"],
        items=[{
            "id": sub["items"]["data"][0].id,
            "quantity": new_screens,
        }],
        proration_behavior="create_prorations",
    )
    sleep()
    print(f"    Upgraded #{customer_info['index']:03d}: screens {customer_info['screens']} -> {new_screens}")
    customer_info["screens"] = new_screens


def apply_downgrade(customer_info):
    """Downgrade a customer to any lower tier."""
    sub = stripe.Subscription.retrieve(customer_info["subscription_id"])
    if sub.status in ("canceled", "incomplete_expired"):
        print(f"    Skipping #{customer_info['index']:03d}: subscription {sub.status}")
        customer_info["cancelled"] = True
        return

    current_plan = customer_info["plan"]
    current_idx = TIER_ORDER.index(current_plan)

    # Pick any tier below current — weighted toward adjacent tiers
    lower_tiers = TIER_ORDER[:current_idx]
    if not lower_tiers:
        return

    # Weight: adjacent tier most likely, further tiers less likely
    # e.g. from enterprise: engage=4, pro_plus=3, standard=2, free=1
    weights = list(range(1, len(lower_tiers) + 1))
    new_plan = random.choices(lower_tiers, weights=weights, k=1)[0]

    new_screens = min(customer_info["screens"], SCREEN_RANGES[new_plan][1])

    stripe.Subscription.modify(
        customer_info["subscription_id"],
        items=[{
            "id": sub["items"]["data"][0].id,
            "price": PRICE_IDS[new_plan],
            "quantity": new_screens,
        }],
        proration_behavior="create_prorations",
    )
    sleep()
    print(f"    Downgraded #{customer_info['index']:03d}: {current_plan} -> {new_plan}")
    customer_info["plan"] = new_plan
    customer_info["screens"] = new_screens


def apply_cancellation(customer_info):
    """Cancel a customer's subscription."""
    stripe.Subscription.cancel(customer_info["subscription_id"])
    sleep()
    print(f"    Cancelled #{customer_info['index']:03d} ({customer_info['plan']})")
    customer_info["cancelled"] = True


def main():
    random.shuffle(CUSTOMER_PLANS)

    frozen_time = months_ago_timestamp(6)
    all_customers = []
    clocks = []

    batches = []
    for i in range(0, len(CUSTOMER_PLANS), 3):
        batches.append(CUSTOMER_PLANS[i:i + 3])

    print(f"Creating {len(CUSTOMER_PLANS)} customers across {len(batches)} test clocks...\n")
    print(f"Frozen time: {datetime.fromtimestamp(frozen_time, tz=timezone.utc).isoformat()}\n")

    # --- Phase 1: Create all clocks, customers, and subscriptions ---
    print("=== Phase 1: Creating test clocks, customers, and subscriptions ===\n")

    customer_index = 1
    for batch_num, batch in enumerate(batches):
        clock = stripe.test_helpers.TestClock.create(
            frozen_time=frozen_time,
            name=f"MRR Clock {batch_num + 1:02d}",
        )
        sleep()
        clocks.append(clock.id)

        print(f"Clock {batch_num + 1}/{len(batches)} ({clock.id}):")

        for plan in batch:
            info = create_customer_with_sub(clock.id, customer_index, plan)
            all_customers.append(info)
            print(f"  Customer #{customer_index:03d}: {plan}, {info['screens']} screens")
            customer_index += 1

    # --- Phase 2: Advance clocks +2 months (months 1-2) ---
    print(f"\n=== Phase 2: Advancing all clocks +2 months (months 1-2) ===\n")

    advance_to_1 = advance_timestamp(frozen_time, 2)
    for clock_id in clocks:
        stripe.test_helpers.TestClock.advance(clock_id, frozen_time=advance_to_1)
        sleep()
    print(f"Advancing to {datetime.fromtimestamp(advance_to_1, tz=timezone.utc).isoformat()}")
    print("Waiting for all clocks to process...")
    for clock_id in clocks:
        wait_for_clock(clock_id)
    print("All clocks ready.\n")

    # --- Phase 3: Apply upgrades and downgrades, then advance +2 months (months 3-4) ---
    print("=== Phase 3: Applying upgrades/downgrades, then advancing (months 3-4) ===\n")

    upgrade_candidates = select_upgrade_candidates(all_customers)
    print(f"Applying {len(upgrade_candidates)} upgrades:")
    for c in upgrade_candidates:
        apply_upgrade(c)

    downgrade_candidates = select_downgrade_candidates(all_customers)
    print(f"\nApplying {len(downgrade_candidates)} downgrades:")
    for c in downgrade_candidates:
        apply_downgrade(c)

    advance_to_2 = advance_timestamp(frozen_time, 4)
    print(f"\nAdvancing to {datetime.fromtimestamp(advance_to_2, tz=timezone.utc).isoformat()}")
    for clock_id in clocks:
        stripe.test_helpers.TestClock.advance(clock_id, frozen_time=advance_to_2)
        sleep()
    print("Waiting for all clocks to process...")
    for clock_id in clocks:
        wait_for_clock(clock_id)
    print("All clocks ready.\n")

    # --- Phase 4: Apply cancellations, then advance +2 months (months 5-6) ---
    print("=== Phase 4: Applying cancellations, then advancing (months 5-6) ===\n")

    cancel_candidates = select_cancel_candidates(all_customers)
    print(f"Applying {len(cancel_candidates)} cancellations:")
    for c in cancel_candidates:
        apply_cancellation(c)

    advance_to_3 = advance_timestamp(frozen_time, 6)
    print(f"\nAdvancing to {datetime.fromtimestamp(advance_to_3, tz=timezone.utc).isoformat()}")
    for clock_id in clocks:
        stripe.test_helpers.TestClock.advance(clock_id, frozen_time=advance_to_3)
        sleep()
    print("Waiting for all clocks to process...")
    for clock_id in clocks:
        wait_for_clock(clock_id)
    print("All clocks ready.\n")

    # --- Summary ---
    print("=== Summary ===\n")
    active = [c for c in all_customers if not c["cancelled"]]
    cancelled = [c for c in all_customers if c["cancelled"]]
    print(f"Total customers created: {len(all_customers)}")
    print(f"Active subscriptions:    {len(active)}")
    print(f"Cancelled:               {len(cancelled)}")
    print(f"Test clocks used:        {len(clocks)}")

    plan_counts = {}
    for c in active:
        plan_counts[c["plan"]] = plan_counts.get(c["plan"], 0) + 1
    print(f"\nActive customers by plan:")
    for plan, count in sorted(plan_counts.items()):
        print(f"  {plan}: {count}")


if __name__ == "__main__":
    main()
